<!DOCTYPE html>
<!--
nanoStream Player
(c) 2020, nanocosmos gmbh
http://www.nanocosmos.de
sales@nanocosmos.de

LEGAL NOTICE:
This material is subject to the terms and conditions defined in
separate license conditions ('LICENSE.txt')
All information contained herein is, and remains the property
of nanocosmos GmbH and its suppliers if any. The intellectual and technical concepts
contained herein are proprietary to nanocosmos GmbH, and are protected by trade secret
or copyright law. Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained from nanocosmos.
All modifications will remain property of nanocosmos.
-->
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <title>nanoplayer</title>
    <link href="//fonts.googleapis.com/css?family=Roboto:300,400,500,700" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="./css/main.css">
    <link rel="shortcut icon" href="./assets/flavicon.ico" type="image/x-icon" />
</head>

<body>
    <div id="container">
        <p class="normal">
            <h1 id="demo-title">nanoStream H5Live Player Demo</h1>
            <strong id="demo-version"></strong>
        </p>
        <div class="row" style="display: flex; height: 400px">
            <div class="col">
                <div id="playerDiv" class="player">
                    <!---->
                    <video id="h5live" playsinline style="display:none;width:100%;height:100%"></video>
                </div>
            </div>
            <!-- <div class="col" style="flex: 1; height: 100%; padding-left: 20px">
                <div id="chartWrapper"
                    class="d-xl-flex col px-4 py-4 mt-4 mt-xl-4 mx-0 background--light card box-shadow__material"
                    style="height: 100%">
                    <div class="row mx-0 font-weight-medium title white--text">
                        Buffer
                    </div>
                    <div class="flex-col flex-1 mt-4" style="overflow: hidden;height: 100%">
                        <canvas id="bitrateChart"></canvas>
                    </div>
                </div>
            </div> -->
        </div>
        <p class="normal">
            <span>
                <strong>controls:&nbsp;</strong>
                <button id="buttonPlay" onclick="play();">play</button>
                <button id="buttonPause" onclick="pause();">pause</button>
                <button id="buttonReset" onclick="startPlayer();">reset</button>
                <!-- <button id="buttonDestroy" onclick="destroyPlayer();">destroy</button> -->
            </span>
            <span style="float:right">
                <span>&nbsp;</span>
                <input type="range" min="0" max="100" id="faderVolume" oninput="setVolume(this, value);"
                    onchange="setVolume(this, value);" />
                <output for="fader" id="volume">100%</output>
            </span>
            <button id="buttonMute" onclick="mute(this);" data-muted="false" style="float:right">mute</button>
            <strong id="friendly-message"></strong>
        </p>
        <p class="normal">
            <strong>switch rule:&nbsp;</strong><span id="switch-rule"></span><span id="back-to-rule"></span>
        </p>
        <div class="col">
            <div class="row">
                <div class="col col-12">
                    <h2>entries (qualities):</h2>
                </div>
            </div>
            <div id="qualitiesWrapper" class="col">
            </div>
        </div>
        <p class="normal" id="warning-container" style="display:none">
            <strong>warning:&nbsp;</strong><span id="warning" style="color:orange"></span>
        </p>
        <p class="normal" id="group-container" style="display:none">
            <strong>group:&nbsp;</strong><span id="group">uninitialized</span>
        </p>
        <p class="normal" id="streams-container" style="display:none">
            <strong>streams:&nbsp;</strong><select id="stream-select" onchange="resetPlayer();"></select>
        </p>
        <!-- <div id="update-source-container" style="display:none">
            <p class="normal" style="display:flex">
                <strong>server:&nbsp;</strong><input id="inputServer" data-prop="server" style="flex:2" />
            </p>
            <p class="normal" style="display:flex">
                <strong>url:&nbsp;</strong><input id="inputUrl" data-prop="url" style="flex:2" />
            </p>
            <p class="normal" style="display:flex">
                <strong>streamname:&nbsp;</strong><input id="inputStreamname" data-prop="streamname" style="flex:2" />
            </p>
            <p class="normal" style="display:flex">
                <button id="buttonUpdateSource" onclick="updateSource();" style="flex:1">update</button>
            </p>
        </div> -->
        <p class="normal">
            <strong>status:&nbsp;</strong><span id="status">uninitialized</span>
        </p>
        <p class="normal">
            <strong>play latency (avg/min/max/dev):&nbsp;</strong><span
                id="bufferTimeDelay">0.0</span><span>/</span><span id="bufferTimeDelayMin">0.0</span><span>/</span><span
                id="bufferTimeDelayMax">0.0</span><span>/</span><span id="bufferTimeDelayDeviation">0.00</span><br />
        </p>
        <p class="normal">
            <strong>current time:&nbsp;</strong><span id="currentTime">0.0</span><br />
        </p>
        <p class="normal">
            <strong>play time (start/end):&nbsp;</strong><span id="playTimeStart">0.0</span><span>/</span><span
                id="playTimeEnd">0.0</span>
        </p>
        <p class="normal">
            <strong>buffer time (start/end):&nbsp;</strong><span id="bufferTimeStart">0.0</span><span>/</span><span
                id="bufferTimeEnd">0.0</span>
        </p>
        <p class="normal">
            <strong>bitrate (avg/min/max/dev):&nbsp;</strong><span id="bitrateAvg">0 kBps</span><span>/</span><span
                id="bitrateMin">0 kBps</span><span>/</span><span id="bitrateMax">0 kBps</span><span>/</span><span
                id="bitrateDeviation">0 kBps</span>
        </p>
        <p class="normal">
            <strong>framerate (current/avg/min/max/dev):&nbsp;</strong><span id="framerateCurrent">0
                kBps</span><span>/</span><span id="framerateAvg">0 kBps</span><span>/</span><span id="framerateMin">0
                kBps</span><span>/</span><span id="framerateMax">0 kBps</span><span>/</span><span
                id="framerateDeviation">0 kBps</span>
        </p>
        <p class="normal">
            <strong>deviationOfMean (dev):&nbsp;</strong><span id="adaptiveBufferTimeDelayDeviation">0.0</span>
        </p>
        <p class="normal" id="metadata-container" style="display:none">
            <strong>metadata:&nbsp;</strong><span id="metadata"></span>
        </p>
        <p class="normal" id="error-container" style="display:none">
            <strong>error:&nbsp;</strong><span id="error" style="color:orangered"></span>
        </p>
        <div id="code-snippet-container" style="display:none">
            <strong>code snippet</strong>
            <pre id="code-snippet"></pre>
        </div>
        <p class="normal">
            <strong>documentation:&nbsp;</strong><a href="../docs/nanoplayer/index.html" target="_blank">open api
                documentation</a>
        </p>
        <p class="normal">
            <strong>log:&nbsp;</strong><br />
            <span id="log"></span>
        </p>
    </div>

    <script>

        // DEFAULT DEMO PAGE H5LIVE SERVER
        var DEFAULT_DEMO_PAGE_H5LIVE_SERVER = 'bintu-h5live.nanocosmos.de';
        var DEFAULT_DEMO_PAGE_H5LIVE_SERVER_WSS = 'wss://bintu-h5live.nanocosmos.de:443/h5live/stream';
        var DEFAULT_DEMO_PAGE_H5LIVE_SERVER_HLS = 'https://bintu-h5live.nanocosmos.de:443/h5live/http/playlist.m3u8';
        var DEFAULT_DEMO_PAGE_H5LIVE_SERVER_PROGRESSIVE = 'https://bintu-h5live.nanocosmos.de:443/h5live/http/stream.mp4'

    </script>
    <script src="./js/nanoplayer-custom-config.js"></script>
    <script src="./js/nanoplayer-helper.js"></script>
    <script src="./js/nanoplayer-helper-events.js"></script>
    <script src="./js/nanoplayer-helper-multistream.js"></script>
    <script src="./js/nanoplayer-metrics-config.js"></script>
    <script src="./js/multi/nano.bintu.js"></script>

    
    
    <script src="./js/nanoplayer/nanoplayer.4.2.4.min.js"></script>
    <script>

        var playerVersion = '4.2.4';
        console.log('nanoplayer html version: ' + playerVersion);
        document.getElementById('demo-version').innerText = 'version ' + playerVersion;

        var getPlayerLocation = function () {
            return '//demo.nanocosmos.de/nanoplayer/api/release/nanoplayer.4.min.js?20200227';
        };

        var player;

        document.addEventListener('DOMContentLoaded', function () {
            var cap = NanoPlayer.capabilities;
            !cap.length ? console.log('no supported player tech') : cap.forEach(function (c) { console.log('supported player tech: ' + c) });
            init();
        });
    </script>
    

    <script>
        function updateStreamQualityWrapper(streamInfo) {
            if (config.source.entries) {

                var streams = config.source.entries;
                var qualitiesWrapper = document.getElementById("qualitiesWrapper");
                var currentStreamname = streamInfo.rtmp ? streamInfo.rtmp.streamname : extractStreamname(streamInfo.url);
                var currentQualityIndex = getCurrentQualityIndex(currentStreamname);

                removeAllChildNodes(qualitiesWrapper);

                for (var i = 0; i < streams.length; i++) {
                    var qualityWrapper = document.createElement("div");
                    qualityWrapper.classList.add("streamQualityWrapper");
                    qualityWrapper.style.cursor = 'pointer';
                    var streamIndex = document.createElement("div");

                    streamIndex.textContent = (i + 1) + ".";
                    qualityWrapper.classList.add("row")
                    qualityWrapper.appendChild(streamIndex);

                    if (i === currentQualityIndex) {
                        streamIndex.classList.add("streamIndex--active");
                        var streamDetailsWrapper = document.createElement("div");
                        streamDetailsWrapper.classList.add("col-12");

                        // TITLE
                        var streamDetailsTitle = document.createElement("div");
                        streamDetailsTitle.classList.add("row");

                        // add streamname
                        var labelStreamname = document.createElement("div");
                        labelStreamname.textContent = streams[i].h5live.rtmp.streamname;
                        labelStreamname.classList.add("labelStreamname");
                        labelStreamname.classList.add("labelStreamname--active");
                        streamDetailsTitle.appendChild(labelStreamname);

                        // SUBTITLE
                        var streamDetailsSubtitle = document.createElement("div");
                        streamDetailsSubtitle.classList.add("col");

                        // add bitrate
                        var labelBitrate = document.createElement("div");
                        labelBitrate.textContent = "Bitrate: " + ((streams[i].info && streams[i].info.bitrate != 0) ? streams[i].info.bitrate : 0);
                        labelBitrate.textContent += " kbit/s";
                        labelBitrate.classList.add("labelBitrate");
                        streamDetailsSubtitle.appendChild(labelBitrate);

                        // add resolution
                        if (streamInfo.videoInfo) {
                            var labelResolution = document.createElement("div");
                            labelResolution.textContent = "Resolution: " + streamInfo.videoInfo.width + "x" + streamInfo.videoInfo.height;
                            labelResolution.classList.add("labelResolution");
                            streamDetailsSubtitle.appendChild(labelResolution);
                        }

                        // add framerate
                        if (streamInfo.videoInfo) {
                            var labelFrameRate = document.createElement("div");
                            labelFrameRate.textContent = "Framerate: " + streamInfo.videoInfo.frameRate + " fps";
                            labelFrameRate.classList.add("labelFrameRate");
                            streamDetailsSubtitle.appendChild(labelFrameRate);
                        }

                        streamDetailsWrapper.appendChild(streamDetailsTitle);
                        streamDetailsWrapper.appendChild(streamDetailsSubtitle);
                        qualityWrapper.appendChild(streamDetailsWrapper);
                    } else {
                        streamIndex.classList.add("streamIndex");
                        var labelStreamname = document.createElement("div");
                        labelStreamname.textContent = streams[i].h5live.rtmp.streamname;
                        labelStreamname.classList.add("labelStreamname");
                        qualityWrapper.appendChild(labelStreamname);
                    }

                    qualityWrapper.addEventListener('click', function (index) {
                        if (player) {
                            player.switchStream(index).then(function(_config){
                                log('switchStream initialized');
                            }, function error(_err) {
                                log('switchStream aborted with error ' + _err.code + ': ' + _err.message);
                            });
                        }
                    }.bind(null, i))

                    qualitiesWrapper.appendChild(qualityWrapper);
                }
            }
        }

        function extractStreamname(streamInfoUrl) {
            var prefix = "stream=";
            var cutOff = streamInfoUrl.substring(streamInfoUrl.indexOf(prefix));
            var streamname = cutOff.substring(prefix.length, cutOff.indexOf("&"));
            return window.decodeURIComponent(streamname);
        }

        function getCurrentQualityIndex(streamname) {
            var currentQualityIndex = 0;

            if (config.source.entries) {
                var entries = config.source.entries;
                for (var i = 0; i < entries.length; i++) {
                    if (entries[i].h5live.rtmp.streamname === streamname) {
                        currentQualityIndex = i;
                        break;
                    }
                }
            }

            return currentQualityIndex;
        }

        function getMaxQualityIndex() {
            return config.source.entries ? config.source.entries.length - 1 : 0;
        }

        function removeAllChildNodes(element) {
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }

        function setRule(rule) {
            var oldRule = document.getElementById('switch-rule').textContent;
            if (rule === 'none' && oldRule !== 'none' && oldRule.length > 0) {
                var button = document.createElement('button');
                button.textContent = 'back to rule \'' + oldRule + '\'';
                button.style.marginLeft = '1em';
                button.addEventListener('click', function () {
                    if (player) {
                        player.updateSource(config.source).then(function (_config) {
                            log('updateSource initialized');
                        }, function error(_err) {
                            log('updateSource aborted with error ' + _err.code + ': ' + _err.message);
                        });
                    }
                }.bind(null));
                document.getElementById('back-to-rule').appendChild(button);
            } else if (rule !== 'none' && document.getElementById('back-to-rule').firstChild) {
                document.getElementById('back-to-rule').removeChild(document.getElementById('back-to-rule').firstChild);
            }
            document.getElementById('switch-rule').textContent = rule;
        }

    </script>

    <script>

        var buffering = {
            start: 0,
            end: 0
        };

        var bintu, bintuQ;
        var metaDataTimeout = 0;
        var forceAutoplay = null;
        var forceMuted = null;

        var searchRefreshInterval = 0;

        var config = {
            source: {},
            playback: {
                autoplay: true,
                automute: true,
                muted: true
            },
            events: {},
            style: {
                displayMutedAutoplay: false
            }
        };
        events = events || {};
        events.onMute = function (e) {
            log('onMute');
            var buttonMute = document.getElementById('buttonMute');
            buttonMute.dataset.muted = true;
            buttonMute.innerText = 'unmute';
        };
        events.onUnmute = function (e) {
            log('onUnmute');
            var buttonMute = document.getElementById('buttonMute');
            buttonMute.dataset.muted = false;
            buttonMute.innerText = 'mute';
        };
        events.onVolumeChange = function (e) {
            log('onVolumeChange ' + e.data.volume * 100);
            var volumeFader = document.getElementById('faderVolume'), volumeOutput = document.getElementById('volume'), volume = Math.round(e.data.volume * 100);
            (parseInt(volumeFader.value) !== volume) && (volumeFader.value = volume);
            volumeOutput.value = volume + '%';
        };

        function init() {
            document.querySelector('#faderVolume').value = 100;
            var doStartPlayer = getNanoPlayerParameters();
            if (doStartPlayer) {
                startPlayer(config);
            }
        }

        function resetPlayer() {
            var select = document.getElementById('stream-select');
            if (!select.options[select.selectedIndex]) {
                return;
            }
            var selectedValue = select.options[select.selectedIndex].value;

            if (!!streamObj) {
                if (streamObj.streamname === selectedValue) {
                    console.log('already playing this stream');
                    return;
                }
            }

            var i, len = streamObjs.length;
            for (i = 0; i < len; i += 1) {
                if (streamObjs[i].streamname === selectedValue)
                    streamObj = streamObjs[i];
            }

            var h5liveQ = {};
            h5liveQ.rtmp = {};
            h5liveQ.rtmp.url = streamObj.url;
            h5liveQ.rtmp.streamname = streamObj.streamname;
            h5liveQ.server = {};
            h5liveQ.server.websocket = streamObj.server.websocket;
            h5liveQ.server.hls = streamObj.server.hls;
            h5liveQ.server.progressive = streamObj.server.progressive;

            config.source.h5live = h5liveQ;

            checkSecurity();
            if (!player) {
                startPlayer();
            } else {
                updateSource();
            }
        }

        function destroyPlayer() {
            if (player) {
                player.destroy();
            }
        }

        function startPlayer(config) {
            if (!player) {
                player = new NanoPlayer('playerDiv');
            }
            config = config || this.config;
            for (var event in events) {
                if (events.hasOwnProperty(event)) {
                    player.on(event.substr(2), events[event]);
                }
            }

            var toString = Object.prototype.toString;
            function deepCopy(obj) {
                var rv;

                switch (typeof obj) {
                    case 'object':
                        if (obj === null) {
                            // null => null
                            rv = null;
                        }
                        else {
                            switch (toString.call(obj)) {
                                case '[object Array]':
                                    // It's an array, create a new array with
                                    // deep copies of the entries
                                    rv = obj.map(deepCopy);
                                    break;
                                case '[object Date]':
                                    // Clone the date
                                    rv = new Date(obj);
                                    break;
                                case '[object RegExp]':
                                    // Clone the RegExp
                                    rv = new RegExp(obj);
                                    break;
                                // ...probably a few others
                                default:
                                    // Some other kind of object, deep-copy its
                                    // properties into a new object
                                    rv = Object.keys(obj).reduce(function (prev, key) {
                                        prev[key] = deepCopy(obj[key]);
                                        return prev;
                                    }, {});
                                    break;
                            }
                        }
                        break;
                    default:
                        // It's a primitive, copy via assignment
                        rv = obj;
                        break;
                }
                return rv;
            }

            if (typeof customConfig !== 'undefined') {
                this.config = customConfig;
            } else if (typeof config !== 'undefined') {
                //var mobile = /(Android|iPhone|iPad|iPod)/.test(navigator.userAgent);
                //config.playback.autoplay = (!mobile && config.playback.autoplay);
                if (forceAutoplay !== null) {
                    config.playback.autoplay = forceAutoplay;
                }
                if (forceMuted !== null) {
                    config.playback.muted = forceMuted;
                }
                this.config = config;
            }
            if (window.nanoPlayerMetricsConfig) {
                this.config.metrics = window.nanoPlayerMetricsConfig;
            }
            var _config = deepCopy(this.config);
            var buttonMute = document.getElementById('buttonMute');
            buttonMute.dataset.muted = _config.playback.muted;
            buttonMute.innerText = _config.playback.muted ? 'unmute' : 'mute';
            createCodeSippet(_config);

            // updateStreamQualityWrapper();
            player.setup(_config).then(function (conf) {
                setVolume(null, document.getElementById('faderVolume').value);
                checkConfig(conf);
                document.getElementById('switch-rule').textContent = conf.source.options.adaption.rule;
                try {
                    conf = JSON.stringify(conf)
                } catch (err) { }
                log('setup ok: ' + conf);

                player.on("StreamInfo", function (e) {
                    var cutOff = e.data.streamInfo.url.substring(e.data.streamInfo.url.indexOf("stream="));
                    console.log(cutOff)
                    var streamname = cutOff.substring(7, cutOff.indexOf("&"))
                    console.log(streamname)
                    updateStreamQualityWrapper(e.data.streamInfo);
                });
                player.on("SwitchStreamInit", function (e) {
                    setRule(e.data.rule);
                });
                player.on("UpdateSourceInit", function (e) {
                    setRule(e.data.rule);
                });

            }, function (error) {
                if (error.message) {
                    error = error.message;
                } else {
                    try {
                        var err = JSON.stringify(error);
                        if (err === '{}') {
                            err = error.message;
                        }
                        error = err;
                    } catch (err) { }
                }
                log('Setup Error: ' + error);
                document.getElementById('status').innerText = 'Setup Error: ' + error;
            });
        }

        function checkConfig(conf) {
            if (document.getElementById('demo-version').innerText !== 'version ' + player.version) {
                alert('The page has been updated during the last few minutes! Please empty your cache!');
            }
            document.getElementById('demo-version').innerText = 'version ' + player.version;
        }

        function play() {
            player.play();
        }

        function pause() {
            player.pause();
        }

        function mute(e) {
            var muted = (e.dataset.muted === 'true') ? true : false;
            if (muted) {
                player.unmute();
            } else {
                player.mute();
            }
        }

        function setVolume(e, value) {
            if (!player) {
                return;
            }
            if (value < 0) {
                value = 0;
            } else if (value > 100) {
                value = 100;
            }
            var volume = value / 100;
            player.setVolume(volume);
        }

        function updateSource() {
            if (!player) {
                return;
            }
            config.source.entries.length > 2 && (config.source.entries[2].h5live.rtmp.streamname += 'x');
            config.source.entries.length > 2 && (config.source.startIndex = 2);
            player.updateSource(config.source).then(function (conf) {
                checkConfig(conf);
                try {
                    conf = JSON.stringify(conf);
                } catch (err) { }
                log('update source ok: ' + conf);
            }, function (error) {
                if (error.message) {
                    error = error.message;
                } else {
                    try {
                        var err = JSON.stringify(error);
                        if (err === '{}') {
                            err = error.message;
                        }
                        error = err;
                    } catch (err) { }
                }
                log('update source error: ' + error);
                document.getElementById('status').innerText = 'Update Source Error: ' + error;
            });
        }

        function createCodeSippet(config) {
            var conf = JSON.parse(JSON.stringify(config));
            delete conf.events;
            conf.playback = conf.playback || {};
            conf.playback.flashplayer = '//demo.nanocosmos.de/nanoplayer/nano.player.swf';
            var pre = document.getElementById('code-snippet');
            pre.innerHTML = '';
            var line = '<div id="playerDiv"></div>\r\n';
            line += '<script src="' + getPlayerLocation() + '"><\/script>\r\n';
            line += '<script>\r\n';
            line += 'var player;\r\n';
            line += 'var config = ' + JSON.stringify(conf, undefined, 4) + ';\r\n';
            line += 'document.addEventListener(\'DOMContentLoaded\', function () {\r\n';
            line += '    player = new NanoPlayer("playerDiv");\r\n';
            line += '    player.setup(config).then(function (config) {\r\n';
            line += '        console.log("setup success");\r\n';
            line += '        console.log("config: " + JSON.stringify(config, undefined, 4));\r\n';
            line += '    }, function (error) {\r\n';
            line += '        alert(error.message);\r\n';
            line += '    });\r\n';
            line += '});\r\n';
            line += '<\/script>\r\n';
            pre.appendChild(document.createTextNode(line));
            document.getElementById('code-snippet-container').style.display = "block";
        }
    </script>
</body>

</html>